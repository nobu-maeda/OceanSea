// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(FatCrabTradingFFI)
    import FatCrabTradingFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_fatcrab_trading_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_fatcrab_trading_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol FatCrabBuyMakerProtocol: AnyObject {
    func getOrderDetails() throws -> FatCrabOrder

    func getPeerPubkey() throws -> String?

    func getState() throws -> FatCrabMakerState

    func postNewOrder() throws -> FatCrabMakerState

    func queryOffers() throws -> [FatCrabOfferEnvelope]

    func queryPeerMsg() throws -> FatCrabPeerEnvelope?

    func registerNotifDelegate(delegate: FatCrabMakerNotifDelegate) throws

    func releaseNotifyPeer() throws -> FatCrabMakerState

    func tradeComplete() throws -> FatCrabMakerState

    func tradeResponse(tradeRspType: FatCrabTradeRspType, offerEnvelope: FatCrabOfferEnvelope) throws -> FatCrabMakerState

    func unregisterNotifDelegate() throws
}

public class FatCrabBuyMaker:
    FatCrabBuyMakerProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcrabbuymaker(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcrabbuymaker(pointer, $0) }
    }

    public func getOrderDetails() throws -> FatCrabOrder {
        return try FfiConverterTypeFatCrabOrder.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_get_order_details(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func getPeerPubkey() throws -> String? {
        return try FfiConverterOptionString.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_get_peer_pubkey(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func getState() throws -> FatCrabMakerState {
        return try FfiConverterTypeFatCrabMakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_get_state(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func postNewOrder() throws -> FatCrabMakerState {
        return try FfiConverterTypeFatCrabMakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_post_new_order(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func queryOffers() throws -> [FatCrabOfferEnvelope] {
        return try FfiConverterSequenceTypeFatCrabOfferEnvelope.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_query_offers(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func queryPeerMsg() throws -> FatCrabPeerEnvelope? {
        return try FfiConverterOptionTypeFatCrabPeerEnvelope.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_query_peer_msg(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func registerNotifDelegate(delegate: FatCrabMakerNotifDelegate) throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_register_notif_delegate(self.uniffiClonePointer(),
                                                                                         FfiConverterTypeFatCrabMakerNotifDelegate.lower(delegate), $0)
            }
    }

    public func releaseNotifyPeer() throws -> FatCrabMakerState {
        return try FfiConverterTypeFatCrabMakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_release_notify_peer(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func tradeComplete() throws -> FatCrabMakerState {
        return try FfiConverterTypeFatCrabMakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_trade_complete(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func tradeResponse(tradeRspType: FatCrabTradeRspType, offerEnvelope: FatCrabOfferEnvelope) throws -> FatCrabMakerState {
        return try FfiConverterTypeFatCrabMakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_trade_response(self.uniffiClonePointer(),
                                                                                FfiConverterTypeFatCrabTradeRspType.lower(tradeRspType),
                                                                                FfiConverterTypeFatCrabOfferEnvelope.lower(offerEnvelope), $0)
            }
        )
    }

    public func unregisterNotifDelegate() throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuymaker_unregister_notif_delegate(self.uniffiClonePointer(), $0)
            }
    }
}

public struct FfiConverterTypeFatCrabBuyMaker: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabBuyMaker

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabBuyMaker {
        return FatCrabBuyMaker(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabBuyMaker) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabBuyMaker {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabBuyMaker, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabBuyMaker_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabBuyMaker {
    return try FfiConverterTypeFatCrabBuyMaker.lift(pointer)
}

public func FfiConverterTypeFatCrabBuyMaker_lower(_ value: FatCrabBuyMaker) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabBuyMaker.lower(value)
}

public protocol FatCrabBuyTakerProtocol: AnyObject {
    func checkBtcTxConfirmation() throws -> UInt32

    func getOrderDetails() throws -> FatCrabOrderEnvelope

    func getPeerBtcTxid() throws -> String?

    func getState() throws -> FatCrabTakerState

    func notifyPeer(fatcrabTxid: String) throws -> FatCrabTakerState

    func queryTradeRsp() throws -> FatCrabTradeRspEnvelope?

    func registerNotifDelegate(delegate: FatCrabTakerNotifDelegate) throws

    func takeOrder() throws -> FatCrabTakerState

    func tradeComplete() throws -> FatCrabTakerState

    func unregisterNotifDelegate() throws
}

public class FatCrabBuyTaker:
    FatCrabBuyTakerProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcrabbuytaker(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcrabbuytaker(pointer, $0) }
    }

    public func checkBtcTxConfirmation() throws -> UInt32 {
        return try FfiConverterUInt32.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuytaker_check_btc_tx_confirmation(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func getOrderDetails() throws -> FatCrabOrderEnvelope {
        return try FfiConverterTypeFatCrabOrderEnvelope.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuytaker_get_order_details(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func getPeerBtcTxid() throws -> String? {
        return try FfiConverterOptionString.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuytaker_get_peer_btc_txid(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func getState() throws -> FatCrabTakerState {
        return try FfiConverterTypeFatCrabTakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuytaker_get_state(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func notifyPeer(fatcrabTxid: String) throws -> FatCrabTakerState {
        return try FfiConverterTypeFatCrabTakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuytaker_notify_peer(self.uniffiClonePointer(),
                                                                             FfiConverterString.lower(fatcrabTxid), $0)
            }
        )
    }

    public func queryTradeRsp() throws -> FatCrabTradeRspEnvelope? {
        return try FfiConverterOptionTypeFatCrabTradeRspEnvelope.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuytaker_query_trade_rsp(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func registerNotifDelegate(delegate: FatCrabTakerNotifDelegate) throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuytaker_register_notif_delegate(self.uniffiClonePointer(),
                                                                                         FfiConverterTypeFatCrabTakerNotifDelegate.lower(delegate), $0)
            }
    }

    public func takeOrder() throws -> FatCrabTakerState {
        return try FfiConverterTypeFatCrabTakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuytaker_take_order(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func tradeComplete() throws -> FatCrabTakerState {
        return try FfiConverterTypeFatCrabTakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuytaker_trade_complete(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func unregisterNotifDelegate() throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabbuytaker_unregister_notif_delegate(self.uniffiClonePointer(), $0)
            }
    }
}

public struct FfiConverterTypeFatCrabBuyTaker: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabBuyTaker

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabBuyTaker {
        return FatCrabBuyTaker(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabBuyTaker) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabBuyTaker {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabBuyTaker, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabBuyTaker_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabBuyTaker {
    return try FfiConverterTypeFatCrabBuyTaker.lift(pointer)
}

public func FfiConverterTypeFatCrabBuyTaker_lower(_ value: FatCrabBuyTaker) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabBuyTaker.lower(value)
}

public protocol FatCrabMakerNotifDelegate: AnyObject {
    func onMakerOfferNotif(offerNotif: FatCrabMakerNotifOfferStruct)

    func onMakerPeerNotif(peerNotif: FatCrabMakerNotifPeerStruct)
}

public class FatCrabMakerNotifDelegateImpl:
    FatCrabMakerNotifDelegate
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcrabmakernotifdelegate(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcrabmakernotifdelegate(pointer, $0) }
    }

    public func onMakerOfferNotif(offerNotif: FatCrabMakerNotifOfferStruct) {
        try!
            rustCall {
                uniffi_fatcrab_trading_fn_method_fatcrabmakernotifdelegate_on_maker_offer_notif(self.uniffiClonePointer(),
                                                                                                FfiConverterTypeFatCrabMakerNotifOfferStruct.lower(offerNotif), $0)
            }
    }

    public func onMakerPeerNotif(peerNotif: FatCrabMakerNotifPeerStruct) {
        try!
            rustCall {
                uniffi_fatcrab_trading_fn_method_fatcrabmakernotifdelegate_on_maker_peer_notif(self.uniffiClonePointer(),
                                                                                               FfiConverterTypeFatCrabMakerNotifPeerStruct.lower(peerNotif), $0)
            }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private typealias UniFFICallbackHandle = UInt64
private class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 1
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for FatCrabMakerNotifDelegate Callback Interface

private let uniffiCallbackInterfaceFatCrabMakerNotifDelegate: ForeignCallback = { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

    func invokeOnMakerOfferNotif(_ swiftCallbackInterface: FatCrabMakerNotifDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onMakerOfferNotif(
                offerNotif: FfiConverterTypeFatCrabMakerNotifOfferStruct.read(from: &reader)
            )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnMakerPeerNotif(_ swiftCallbackInterface: FatCrabMakerNotifDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onMakerPeerNotif(
                peerNotif: FfiConverterTypeFatCrabMakerNotifPeerStruct.read(from: &reader)
            )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    switch method {
    case IDX_CALLBACK_FREE:
        FfiConverterTypeFatCrabMakerNotifDelegate.handleMap.remove(handle: handle)
        // Successful return
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_SUCCESS
    case 1:
        guard let cb = FfiConverterTypeFatCrabMakerNotifDelegate.handleMap.get(handle: handle) else {
            out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeOnMakerOfferNotif(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
    case 2:
        guard let cb = FfiConverterTypeFatCrabMakerNotifDelegate.handleMap.get(handle: handle) else {
            out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeOnMakerPeerNotif(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }

    // This should never happen, because an out of bounds method index won't
    // ever be used. Once we can catch errors, we should return an InternalError.
    // https://github.com/mozilla/uniffi-rs/issues/351
    default:
        // An unexpected error happened.
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

private func uniffiCallbackInitFatCrabMakerNotifDelegate() {
    uniffi_fatcrab_trading_fn_init_callback_fatcrabmakernotifdelegate(uniffiCallbackInterfaceFatCrabMakerNotifDelegate)
}

public struct FfiConverterTypeFatCrabMakerNotifDelegate: FfiConverter {
    fileprivate static var handleMap = UniFFICallbackHandleMap<FatCrabMakerNotifDelegate>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabMakerNotifDelegate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabMakerNotifDelegate {
        return FatCrabMakerNotifDelegateImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabMakerNotifDelegate) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabMakerNotifDelegate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabMakerNotifDelegate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabMakerNotifDelegate_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabMakerNotifDelegate {
    return try FfiConverterTypeFatCrabMakerNotifDelegate.lift(pointer)
}

public func FfiConverterTypeFatCrabMakerNotifDelegate_lower(_ value: FatCrabMakerNotifDelegate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabMakerNotifDelegate.lower(value)
}

public protocol FatCrabOfferEnvelopeProtocol: AnyObject {
    func pubkey() -> String
}

public class FatCrabOfferEnvelope:
    FatCrabOfferEnvelopeProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcrabofferenvelope(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcrabofferenvelope(pointer, $0) }
    }

    public func pubkey() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcrabofferenvelope_pubkey(self.uniffiClonePointer(), $0)
                }
        )
    }
}

public struct FfiConverterTypeFatCrabOfferEnvelope: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabOfferEnvelope

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabOfferEnvelope {
        return FatCrabOfferEnvelope(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabOfferEnvelope) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabOfferEnvelope {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabOfferEnvelope, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabOfferEnvelope_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabOfferEnvelope {
    return try FfiConverterTypeFatCrabOfferEnvelope.lift(pointer)
}

public func FfiConverterTypeFatCrabOfferEnvelope_lower(_ value: FatCrabOfferEnvelope) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabOfferEnvelope.lower(value)
}

public protocol FatCrabOrderEnvelopeProtocol: AnyObject {
    func order() -> FatCrabOrder

    func pubkey() -> String
}

public class FatCrabOrderEnvelope:
    FatCrabOrderEnvelopeProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcraborderenvelope(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcraborderenvelope(pointer, $0) }
    }

    public func order() -> FatCrabOrder {
        return try! FfiConverterTypeFatCrabOrder.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcraborderenvelope_order(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func pubkey() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcraborderenvelope_pubkey(self.uniffiClonePointer(), $0)
                }
        )
    }
}

public struct FfiConverterTypeFatCrabOrderEnvelope: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabOrderEnvelope

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabOrderEnvelope {
        return FatCrabOrderEnvelope(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabOrderEnvelope) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabOrderEnvelope {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabOrderEnvelope, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabOrderEnvelope_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabOrderEnvelope {
    return try FfiConverterTypeFatCrabOrderEnvelope.lift(pointer)
}

public func FfiConverterTypeFatCrabOrderEnvelope_lower(_ value: FatCrabOrderEnvelope) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabOrderEnvelope.lower(value)
}

public protocol FatCrabPeerEnvelopeProtocol: AnyObject {
    func message() -> FatCrabPeerMessage
}

public class FatCrabPeerEnvelope:
    FatCrabPeerEnvelopeProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcrabpeerenvelope(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcrabpeerenvelope(pointer, $0) }
    }

    public func message() -> FatCrabPeerMessage {
        return try! FfiConverterTypeFatCrabPeerMessage.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcrabpeerenvelope_message(self.uniffiClonePointer(), $0)
                }
        )
    }
}

public struct FfiConverterTypeFatCrabPeerEnvelope: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabPeerEnvelope

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabPeerEnvelope {
        return FatCrabPeerEnvelope(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabPeerEnvelope) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabPeerEnvelope {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabPeerEnvelope, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabPeerEnvelope_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabPeerEnvelope {
    return try FfiConverterTypeFatCrabPeerEnvelope.lift(pointer)
}

public func FfiConverterTypeFatCrabPeerEnvelope_lower(_ value: FatCrabPeerEnvelope) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabPeerEnvelope.lower(value)
}

public protocol FatCrabSellMakerProtocol: AnyObject {
    func checkBtcTxConfirmation() throws -> UInt32

    func getOrderDetails() throws -> FatCrabOrder

    func getPeerBtcTxid() throws -> String?

    func getPeerPubkey() throws -> String?

    func getState() throws -> FatCrabMakerState

    func notifyPeer(fatcrabTxid: String) throws -> FatCrabMakerState

    func postNewOrder() throws -> FatCrabMakerState

    func queryOffers() throws -> [FatCrabOfferEnvelope]

    func queryPeerMsg() throws -> FatCrabPeerEnvelope?

    func registerNotifDelegate(delegate: FatCrabMakerNotifDelegate) throws

    func tradeComplete() throws -> FatCrabMakerState

    func tradeResponse(tradeRspType: FatCrabTradeRspType, offerEnvelope: FatCrabOfferEnvelope) throws -> FatCrabMakerState

    func unregisterNotifDelegate() throws
}

public class FatCrabSellMaker:
    FatCrabSellMakerProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcrabsellmaker(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcrabsellmaker(pointer, $0) }
    }

    public func checkBtcTxConfirmation() throws -> UInt32 {
        return try FfiConverterUInt32.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_check_btc_tx_confirmation(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func getOrderDetails() throws -> FatCrabOrder {
        return try FfiConverterTypeFatCrabOrder.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_get_order_details(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func getPeerBtcTxid() throws -> String? {
        return try FfiConverterOptionString.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_get_peer_btc_txid(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func getPeerPubkey() throws -> String? {
        return try FfiConverterOptionString.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_get_peer_pubkey(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func getState() throws -> FatCrabMakerState {
        return try FfiConverterTypeFatCrabMakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_get_state(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func notifyPeer(fatcrabTxid: String) throws -> FatCrabMakerState {
        return try FfiConverterTypeFatCrabMakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_notify_peer(self.uniffiClonePointer(),
                                                                              FfiConverterString.lower(fatcrabTxid), $0)
            }
        )
    }

    public func postNewOrder() throws -> FatCrabMakerState {
        return try FfiConverterTypeFatCrabMakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_post_new_order(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func queryOffers() throws -> [FatCrabOfferEnvelope] {
        return try FfiConverterSequenceTypeFatCrabOfferEnvelope.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_query_offers(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func queryPeerMsg() throws -> FatCrabPeerEnvelope? {
        return try FfiConverterOptionTypeFatCrabPeerEnvelope.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_query_peer_msg(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func registerNotifDelegate(delegate: FatCrabMakerNotifDelegate) throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_register_notif_delegate(self.uniffiClonePointer(),
                                                                                          FfiConverterTypeFatCrabMakerNotifDelegate.lower(delegate), $0)
            }
    }

    public func tradeComplete() throws -> FatCrabMakerState {
        return try FfiConverterTypeFatCrabMakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_trade_complete(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func tradeResponse(tradeRspType: FatCrabTradeRspType, offerEnvelope: FatCrabOfferEnvelope) throws -> FatCrabMakerState {
        return try FfiConverterTypeFatCrabMakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_trade_response(self.uniffiClonePointer(),
                                                                                 FfiConverterTypeFatCrabTradeRspType.lower(tradeRspType),
                                                                                 FfiConverterTypeFatCrabOfferEnvelope.lower(offerEnvelope), $0)
            }
        )
    }

    public func unregisterNotifDelegate() throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabsellmaker_unregister_notif_delegate(self.uniffiClonePointer(), $0)
            }
    }
}

public struct FfiConverterTypeFatCrabSellMaker: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabSellMaker

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabSellMaker {
        return FatCrabSellMaker(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabSellMaker) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabSellMaker {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabSellMaker, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabSellMaker_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabSellMaker {
    return try FfiConverterTypeFatCrabSellMaker.lift(pointer)
}

public func FfiConverterTypeFatCrabSellMaker_lower(_ value: FatCrabSellMaker) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabSellMaker.lower(value)
}

public protocol FatCrabSellTakerProtocol: AnyObject {
    func getOrderDetails() throws -> FatCrabOrderEnvelope

    func getState() throws -> FatCrabTakerState

    func registerNotifDelegate(delegate: FatCrabTakerNotifDelegate) throws

    func takeOrder() throws -> FatCrabTakerState

    func tradeComplete() throws -> FatCrabTakerState

    func unregisterNotifDelegate() throws
}

public class FatCrabSellTaker:
    FatCrabSellTakerProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcrabselltaker(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcrabselltaker(pointer, $0) }
    }

    public func getOrderDetails() throws -> FatCrabOrderEnvelope {
        return try FfiConverterTypeFatCrabOrderEnvelope.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabselltaker_get_order_details(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func getState() throws -> FatCrabTakerState {
        return try FfiConverterTypeFatCrabTakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabselltaker_get_state(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func registerNotifDelegate(delegate: FatCrabTakerNotifDelegate) throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabselltaker_register_notif_delegate(self.uniffiClonePointer(),
                                                                                          FfiConverterTypeFatCrabTakerNotifDelegate.lower(delegate), $0)
            }
    }

    public func takeOrder() throws -> FatCrabTakerState {
        return try FfiConverterTypeFatCrabTakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabselltaker_take_order(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func tradeComplete() throws -> FatCrabTakerState {
        return try FfiConverterTypeFatCrabTakerState.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabselltaker_trade_complete(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func unregisterNotifDelegate() throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabselltaker_unregister_notif_delegate(self.uniffiClonePointer(), $0)
            }
    }
}

public struct FfiConverterTypeFatCrabSellTaker: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabSellTaker

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabSellTaker {
        return FatCrabSellTaker(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabSellTaker) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabSellTaker {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabSellTaker, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabSellTaker_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabSellTaker {
    return try FfiConverterTypeFatCrabSellTaker.lift(pointer)
}

public func FfiConverterTypeFatCrabSellTaker_lower(_ value: FatCrabSellTaker) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabSellTaker.lower(value)
}

public protocol FatCrabTakerNotifDelegate: AnyObject {
    func onTakerPeerNotif(peerNotif: FatCrabTakerNotifPeerStruct)

    func onTakerTradeRspNotif(tradeRspNotif: FatCrabTakerNotifTradeRspStruct)
}

public class FatCrabTakerNotifDelegateImpl:
    FatCrabTakerNotifDelegate
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcrabtakernotifdelegate(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcrabtakernotifdelegate(pointer, $0) }
    }

    public func onTakerPeerNotif(peerNotif: FatCrabTakerNotifPeerStruct) {
        try!
            rustCall {
                uniffi_fatcrab_trading_fn_method_fatcrabtakernotifdelegate_on_taker_peer_notif(self.uniffiClonePointer(),
                                                                                               FfiConverterTypeFatCrabTakerNotifPeerStruct.lower(peerNotif), $0)
            }
    }

    public func onTakerTradeRspNotif(tradeRspNotif: FatCrabTakerNotifTradeRspStruct) {
        try!
            rustCall {
                uniffi_fatcrab_trading_fn_method_fatcrabtakernotifdelegate_on_taker_trade_rsp_notif(self.uniffiClonePointer(),
                                                                                                    FfiConverterTypeFatCrabTakerNotifTradeRspStruct.lower(tradeRspNotif), $0)
            }
    }
}

// Declaration and FfiConverters for FatCrabTakerNotifDelegate Callback Interface

private let uniffiCallbackInterfaceFatCrabTakerNotifDelegate: ForeignCallback = { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

    func invokeOnTakerPeerNotif(_ swiftCallbackInterface: FatCrabTakerNotifDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onTakerPeerNotif(
                peerNotif: FfiConverterTypeFatCrabTakerNotifPeerStruct.read(from: &reader)
            )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnTakerTradeRspNotif(_ swiftCallbackInterface: FatCrabTakerNotifDelegate, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onTakerTradeRspNotif(
                tradeRspNotif: FfiConverterTypeFatCrabTakerNotifTradeRspStruct.read(from: &reader)
            )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    switch method {
    case IDX_CALLBACK_FREE:
        FfiConverterTypeFatCrabTakerNotifDelegate.handleMap.remove(handle: handle)
        // Successful return
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_SUCCESS
    case 1:
        guard let cb = FfiConverterTypeFatCrabTakerNotifDelegate.handleMap.get(handle: handle) else {
            out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeOnTakerPeerNotif(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
    case 2:
        guard let cb = FfiConverterTypeFatCrabTakerNotifDelegate.handleMap.get(handle: handle) else {
            out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeOnTakerTradeRspNotif(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }

    // This should never happen, because an out of bounds method index won't
    // ever be used. Once we can catch errors, we should return an InternalError.
    // https://github.com/mozilla/uniffi-rs/issues/351
    default:
        // An unexpected error happened.
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

private func uniffiCallbackInitFatCrabTakerNotifDelegate() {
    uniffi_fatcrab_trading_fn_init_callback_fatcrabtakernotifdelegate(uniffiCallbackInterfaceFatCrabTakerNotifDelegate)
}

public struct FfiConverterTypeFatCrabTakerNotifDelegate: FfiConverter {
    fileprivate static var handleMap = UniFFICallbackHandleMap<FatCrabTakerNotifDelegate>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabTakerNotifDelegate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabTakerNotifDelegate {
        return FatCrabTakerNotifDelegateImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabTakerNotifDelegate) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabTakerNotifDelegate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabTakerNotifDelegate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabTakerNotifDelegate_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabTakerNotifDelegate {
    return try FfiConverterTypeFatCrabTakerNotifDelegate.lift(pointer)
}

public func FfiConverterTypeFatCrabTakerNotifDelegate_lower(_ value: FatCrabTakerNotifDelegate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabTakerNotifDelegate.lower(value)
}

public protocol FatCrabTradeRspEnvelopeProtocol: AnyObject {
    func tradeRsp() -> FatCrabTradeRsp
}

public class FatCrabTradeRspEnvelope:
    FatCrabTradeRspEnvelopeProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcrabtraderspenvelope(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcrabtraderspenvelope(pointer, $0) }
    }

    public func tradeRsp() -> FatCrabTradeRsp {
        return try! FfiConverterTypeFatCrabTradeRsp.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcrabtraderspenvelope_trade_rsp(self.uniffiClonePointer(), $0)
                }
        )
    }
}

public struct FfiConverterTypeFatCrabTradeRspEnvelope: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabTradeRspEnvelope

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabTradeRspEnvelope {
        return FatCrabTradeRspEnvelope(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabTradeRspEnvelope) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabTradeRspEnvelope {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabTradeRspEnvelope, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabTradeRspEnvelope_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabTradeRspEnvelope {
    return try FfiConverterTypeFatCrabTradeRspEnvelope.lift(pointer)
}

public func FfiConverterTypeFatCrabTradeRspEnvelope_lower(_ value: FatCrabTradeRspEnvelope) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabTradeRspEnvelope.lower(value)
}

public protocol FatCrabTraderProtocol: AnyObject {
    func addRelays(relayAddrs: [RelayAddr]) throws

    func getBuyMakers() -> [String: FatCrabBuyMaker]

    func getBuyTakers() -> [String: FatCrabBuyTaker]

    func getRelays() -> [RelayInfo]

    func getSellMakers() -> [String: FatCrabSellMaker]

    func getSellTakers() -> [String: FatCrabSellTaker]

    func newBuyMaker(order: FatCrabOrder, fatcrabRxAddr: String) throws -> FatCrabBuyMaker

    func newBuyTaker(orderEnvelope: FatCrabOrderEnvelope) throws -> FatCrabBuyTaker

    func newSellMaker(order: FatCrabOrder) throws -> FatCrabSellMaker

    func newSellTaker(orderEnvelope: FatCrabOrderEnvelope, fatcrabRxAddr: String) throws -> FatCrabSellTaker

    func nostrPubkey() -> String

    func queryOrders(orderType: FatCrabOrderType?) throws -> [FatCrabOrderEnvelope]

    func reconnect() throws

    func removeRelay(url: String) throws

    func shutdown() throws

    func walletBalances() throws -> Balances

    func walletBip39Mnemonic() throws -> String

    func walletBlockchainSync() throws

    func walletGenerateReceiveAddress() throws -> String

    func walletSendToAddress(address: String, amount: UInt64) throws -> String
}

public class FatCrabTrader:
    FatCrabTraderProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_fatcrab_trading_fn_clone_fatcrabtrader(self.pointer, $0) }
    }

    public convenience init(info: BlockchainInfo, appDirPath: String) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_fatcrab_trading_fn_constructor_fatcrabtrader_new(
                FfiConverterTypeBlockchainInfo.lower(info),
                FfiConverterString.lower(appDirPath), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_fatcrab_trading_fn_free_fatcrabtrader(pointer, $0) }
    }

    public static func newWithMnemonic(mnemonic: String, info: BlockchainInfo, appDirPath: String) -> FatCrabTrader {
        return FatCrabTrader(unsafeFromRawPointer: try! rustCall {
            uniffi_fatcrab_trading_fn_constructor_fatcrabtrader_new_with_mnemonic(
                FfiConverterString.lower(mnemonic),
                FfiConverterTypeBlockchainInfo.lower(info),
                FfiConverterString.lower(appDirPath), $0
            )
        })
    }

    public func addRelays(relayAddrs: [RelayAddr]) throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_add_relays(self.uniffiClonePointer(),
                                                                          FfiConverterSequenceTypeRelayAddr.lower(relayAddrs), $0)
            }
    }

    public func getBuyMakers() -> [String: FatCrabBuyMaker] {
        return try! FfiConverterDictionaryStringTypeFatCrabBuyMaker.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcrabtrader_get_buy_makers(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func getBuyTakers() -> [String: FatCrabBuyTaker] {
        return try! FfiConverterDictionaryStringTypeFatCrabBuyTaker.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcrabtrader_get_buy_takers(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func getRelays() -> [RelayInfo] {
        return try! FfiConverterSequenceTypeRelayInfo.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcrabtrader_get_relays(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func getSellMakers() -> [String: FatCrabSellMaker] {
        return try! FfiConverterDictionaryStringTypeFatCrabSellMaker.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcrabtrader_get_sell_makers(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func getSellTakers() -> [String: FatCrabSellTaker] {
        return try! FfiConverterDictionaryStringTypeFatCrabSellTaker.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcrabtrader_get_sell_takers(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func newBuyMaker(order: FatCrabOrder, fatcrabRxAddr: String) throws -> FatCrabBuyMaker {
        return try FfiConverterTypeFatCrabBuyMaker.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_new_buy_maker(self.uniffiClonePointer(),
                                                                             FfiConverterTypeFatCrabOrder.lower(order),
                                                                             FfiConverterString.lower(fatcrabRxAddr), $0)
            }
        )
    }

    public func newBuyTaker(orderEnvelope: FatCrabOrderEnvelope) throws -> FatCrabBuyTaker {
        return try FfiConverterTypeFatCrabBuyTaker.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_new_buy_taker(self.uniffiClonePointer(),
                                                                             FfiConverterTypeFatCrabOrderEnvelope.lower(orderEnvelope), $0)
            }
        )
    }

    public func newSellMaker(order: FatCrabOrder) throws -> FatCrabSellMaker {
        return try FfiConverterTypeFatCrabSellMaker.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_new_sell_maker(self.uniffiClonePointer(),
                                                                              FfiConverterTypeFatCrabOrder.lower(order), $0)
            }
        )
    }

    public func newSellTaker(orderEnvelope: FatCrabOrderEnvelope, fatcrabRxAddr: String) throws -> FatCrabSellTaker {
        return try FfiConverterTypeFatCrabSellTaker.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_new_sell_taker(self.uniffiClonePointer(),
                                                                              FfiConverterTypeFatCrabOrderEnvelope.lower(orderEnvelope),
                                                                              FfiConverterString.lower(fatcrabRxAddr), $0)
            }
        )
    }

    public func nostrPubkey() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_fatcrab_trading_fn_method_fatcrabtrader_nostr_pubkey(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func queryOrders(orderType: FatCrabOrderType?) throws -> [FatCrabOrderEnvelope] {
        return try FfiConverterSequenceTypeFatCrabOrderEnvelope.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_query_orders(self.uniffiClonePointer(),
                                                                            FfiConverterOptionTypeFatCrabOrderType.lower(orderType), $0)
            }
        )
    }

    public func reconnect() throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_reconnect(self.uniffiClonePointer(), $0)
            }
    }

    public func removeRelay(url: String) throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_remove_relay(self.uniffiClonePointer(),
                                                                            FfiConverterString.lower(url), $0)
            }
    }

    public func shutdown() throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_shutdown(self.uniffiClonePointer(), $0)
            }
    }

    public func walletBalances() throws -> Balances {
        return try FfiConverterTypeBalances.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_wallet_balances(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func walletBip39Mnemonic() throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_wallet_bip39_mnemonic(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func walletBlockchainSync() throws {
        try
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_wallet_blockchain_sync(self.uniffiClonePointer(), $0)
            }
    }

    public func walletGenerateReceiveAddress() throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_wallet_generate_receive_address(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func walletSendToAddress(address: String, amount: UInt64) throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeFatCrabError.lift) {
                uniffi_fatcrab_trading_fn_method_fatcrabtrader_wallet_send_to_address(self.uniffiClonePointer(),
                                                                                      FfiConverterString.lower(address),
                                                                                      FfiConverterUInt64.lower(amount), $0)
            }
        )
    }
}

public struct FfiConverterTypeFatCrabTrader: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FatCrabTrader

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabTrader {
        return FatCrabTrader(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FatCrabTrader) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabTrader {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FatCrabTrader, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFatCrabTrader_lift(_ pointer: UnsafeMutableRawPointer) throws -> FatCrabTrader {
    return try FfiConverterTypeFatCrabTrader.lift(pointer)
}

public func FfiConverterTypeFatCrabTrader_lower(_ value: FatCrabTrader) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFatCrabTrader.lower(value)
}

public struct Balances {
    public var immature: UInt64
    public var trustedPending: UInt64
    public var untrustedPending: UInt64
    public var confirmed: UInt64
    public var allocated: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        immature: UInt64,
        trustedPending: UInt64,
        untrustedPending: UInt64,
        confirmed: UInt64,
        allocated: UInt64
    ) {
        self.immature = immature
        self.trustedPending = trustedPending
        self.untrustedPending = untrustedPending
        self.confirmed = confirmed
        self.allocated = allocated
    }
}

extension Balances: Equatable, Hashable {
    public static func == (lhs: Balances, rhs: Balances) -> Bool {
        if lhs.immature != rhs.immature {
            return false
        }
        if lhs.trustedPending != rhs.trustedPending {
            return false
        }
        if lhs.untrustedPending != rhs.untrustedPending {
            return false
        }
        if lhs.confirmed != rhs.confirmed {
            return false
        }
        if lhs.allocated != rhs.allocated {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(immature)
        hasher.combine(trustedPending)
        hasher.combine(untrustedPending)
        hasher.combine(confirmed)
        hasher.combine(allocated)
    }
}

public struct FfiConverterTypeBalances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balances {
        return
            try Balances(
                immature: FfiConverterUInt64.read(from: &buf),
                trustedPending: FfiConverterUInt64.read(from: &buf),
                untrustedPending: FfiConverterUInt64.read(from: &buf),
                confirmed: FfiConverterUInt64.read(from: &buf),
                allocated: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: Balances, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.immature, into: &buf)
        FfiConverterUInt64.write(value.trustedPending, into: &buf)
        FfiConverterUInt64.write(value.untrustedPending, into: &buf)
        FfiConverterUInt64.write(value.confirmed, into: &buf)
        FfiConverterUInt64.write(value.allocated, into: &buf)
    }
}

public func FfiConverterTypeBalances_lift(_ buf: RustBuffer) throws -> Balances {
    return try FfiConverterTypeBalances.lift(buf)
}

public func FfiConverterTypeBalances_lower(_ value: Balances) -> RustBuffer {
    return FfiConverterTypeBalances.lower(value)
}

public struct FatCrabMakerNotifOfferStruct {
    public var state: FatCrabMakerState
    public var offerEnvelope: FatCrabOfferEnvelope

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        state: FatCrabMakerState,
        offerEnvelope: FatCrabOfferEnvelope
    ) {
        self.state = state
        self.offerEnvelope = offerEnvelope
    }
}

public struct FfiConverterTypeFatCrabMakerNotifOfferStruct: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabMakerNotifOfferStruct {
        return
            try FatCrabMakerNotifOfferStruct(
                state: FfiConverterTypeFatCrabMakerState.read(from: &buf),
                offerEnvelope: FfiConverterTypeFatCrabOfferEnvelope.read(from: &buf)
            )
    }

    public static func write(_ value: FatCrabMakerNotifOfferStruct, into buf: inout [UInt8]) {
        FfiConverterTypeFatCrabMakerState.write(value.state, into: &buf)
        FfiConverterTypeFatCrabOfferEnvelope.write(value.offerEnvelope, into: &buf)
    }
}

public func FfiConverterTypeFatCrabMakerNotifOfferStruct_lift(_ buf: RustBuffer) throws -> FatCrabMakerNotifOfferStruct {
    return try FfiConverterTypeFatCrabMakerNotifOfferStruct.lift(buf)
}

public func FfiConverterTypeFatCrabMakerNotifOfferStruct_lower(_ value: FatCrabMakerNotifOfferStruct) -> RustBuffer {
    return FfiConverterTypeFatCrabMakerNotifOfferStruct.lower(value)
}

public struct FatCrabMakerNotifPeerStruct {
    public var state: FatCrabMakerState
    public var peerEnvelope: FatCrabPeerEnvelope

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        state: FatCrabMakerState,
        peerEnvelope: FatCrabPeerEnvelope
    ) {
        self.state = state
        self.peerEnvelope = peerEnvelope
    }
}

public struct FfiConverterTypeFatCrabMakerNotifPeerStruct: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabMakerNotifPeerStruct {
        return
            try FatCrabMakerNotifPeerStruct(
                state: FfiConverterTypeFatCrabMakerState.read(from: &buf),
                peerEnvelope: FfiConverterTypeFatCrabPeerEnvelope.read(from: &buf)
            )
    }

    public static func write(_ value: FatCrabMakerNotifPeerStruct, into buf: inout [UInt8]) {
        FfiConverterTypeFatCrabMakerState.write(value.state, into: &buf)
        FfiConverterTypeFatCrabPeerEnvelope.write(value.peerEnvelope, into: &buf)
    }
}

public func FfiConverterTypeFatCrabMakerNotifPeerStruct_lift(_ buf: RustBuffer) throws -> FatCrabMakerNotifPeerStruct {
    return try FfiConverterTypeFatCrabMakerNotifPeerStruct.lift(buf)
}

public func FfiConverterTypeFatCrabMakerNotifPeerStruct_lower(_ value: FatCrabMakerNotifPeerStruct) -> RustBuffer {
    return FfiConverterTypeFatCrabMakerNotifPeerStruct.lower(value)
}

public struct FatCrabOrder {
    public var orderType: FatCrabOrderType
    public var tradeUuid: String
    public var amount: Double
    public var price: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        orderType: FatCrabOrderType,
        tradeUuid: String,
        amount: Double,
        price: Double
    ) {
        self.orderType = orderType
        self.tradeUuid = tradeUuid
        self.amount = amount
        self.price = price
    }
}

extension FatCrabOrder: Equatable, Hashable {
    public static func == (lhs: FatCrabOrder, rhs: FatCrabOrder) -> Bool {
        if lhs.orderType != rhs.orderType {
            return false
        }
        if lhs.tradeUuid != rhs.tradeUuid {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.price != rhs.price {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(orderType)
        hasher.combine(tradeUuid)
        hasher.combine(amount)
        hasher.combine(price)
    }
}

public struct FfiConverterTypeFatCrabOrder: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabOrder {
        return
            try FatCrabOrder(
                orderType: FfiConverterTypeFatCrabOrderType.read(from: &buf),
                tradeUuid: FfiConverterString.read(from: &buf),
                amount: FfiConverterDouble.read(from: &buf),
                price: FfiConverterDouble.read(from: &buf)
            )
    }

    public static func write(_ value: FatCrabOrder, into buf: inout [UInt8]) {
        FfiConverterTypeFatCrabOrderType.write(value.orderType, into: &buf)
        FfiConverterString.write(value.tradeUuid, into: &buf)
        FfiConverterDouble.write(value.amount, into: &buf)
        FfiConverterDouble.write(value.price, into: &buf)
    }
}

public func FfiConverterTypeFatCrabOrder_lift(_ buf: RustBuffer) throws -> FatCrabOrder {
    return try FfiConverterTypeFatCrabOrder.lift(buf)
}

public func FfiConverterTypeFatCrabOrder_lower(_ value: FatCrabOrder) -> RustBuffer {
    return FfiConverterTypeFatCrabOrder.lower(value)
}

public struct FatCrabPeerMessage {
    public var receiveAddress: String
    public var txid: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        receiveAddress: String,
        txid: String
    ) {
        self.receiveAddress = receiveAddress
        self.txid = txid
    }
}

extension FatCrabPeerMessage: Equatable, Hashable {
    public static func == (lhs: FatCrabPeerMessage, rhs: FatCrabPeerMessage) -> Bool {
        if lhs.receiveAddress != rhs.receiveAddress {
            return false
        }
        if lhs.txid != rhs.txid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(receiveAddress)
        hasher.combine(txid)
    }
}

public struct FfiConverterTypeFatCrabPeerMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabPeerMessage {
        return
            try FatCrabPeerMessage(
                receiveAddress: FfiConverterString.read(from: &buf),
                txid: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: FatCrabPeerMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.receiveAddress, into: &buf)
        FfiConverterString.write(value.txid, into: &buf)
    }
}

public func FfiConverterTypeFatCrabPeerMessage_lift(_ buf: RustBuffer) throws -> FatCrabPeerMessage {
    return try FfiConverterTypeFatCrabPeerMessage.lift(buf)
}

public func FfiConverterTypeFatCrabPeerMessage_lower(_ value: FatCrabPeerMessage) -> RustBuffer {
    return FfiConverterTypeFatCrabPeerMessage.lower(value)
}

public struct FatCrabTakerNotifPeerStruct {
    public var state: FatCrabTakerState
    public var peerEnvelope: FatCrabPeerEnvelope

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        state: FatCrabTakerState,
        peerEnvelope: FatCrabPeerEnvelope
    ) {
        self.state = state
        self.peerEnvelope = peerEnvelope
    }
}

public struct FfiConverterTypeFatCrabTakerNotifPeerStruct: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabTakerNotifPeerStruct {
        return
            try FatCrabTakerNotifPeerStruct(
                state: FfiConverterTypeFatCrabTakerState.read(from: &buf),
                peerEnvelope: FfiConverterTypeFatCrabPeerEnvelope.read(from: &buf)
            )
    }

    public static func write(_ value: FatCrabTakerNotifPeerStruct, into buf: inout [UInt8]) {
        FfiConverterTypeFatCrabTakerState.write(value.state, into: &buf)
        FfiConverterTypeFatCrabPeerEnvelope.write(value.peerEnvelope, into: &buf)
    }
}

public func FfiConverterTypeFatCrabTakerNotifPeerStruct_lift(_ buf: RustBuffer) throws -> FatCrabTakerNotifPeerStruct {
    return try FfiConverterTypeFatCrabTakerNotifPeerStruct.lift(buf)
}

public func FfiConverterTypeFatCrabTakerNotifPeerStruct_lower(_ value: FatCrabTakerNotifPeerStruct) -> RustBuffer {
    return FfiConverterTypeFatCrabTakerNotifPeerStruct.lower(value)
}

public struct FatCrabTakerNotifTradeRspStruct {
    public var state: FatCrabTakerState
    public var tradeRspEnvelope: FatCrabTradeRspEnvelope

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        state: FatCrabTakerState,
        tradeRspEnvelope: FatCrabTradeRspEnvelope
    ) {
        self.state = state
        self.tradeRspEnvelope = tradeRspEnvelope
    }
}

public struct FfiConverterTypeFatCrabTakerNotifTradeRspStruct: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabTakerNotifTradeRspStruct {
        return
            try FatCrabTakerNotifTradeRspStruct(
                state: FfiConverterTypeFatCrabTakerState.read(from: &buf),
                tradeRspEnvelope: FfiConverterTypeFatCrabTradeRspEnvelope.read(from: &buf)
            )
    }

    public static func write(_ value: FatCrabTakerNotifTradeRspStruct, into buf: inout [UInt8]) {
        FfiConverterTypeFatCrabTakerState.write(value.state, into: &buf)
        FfiConverterTypeFatCrabTradeRspEnvelope.write(value.tradeRspEnvelope, into: &buf)
    }
}

public func FfiConverterTypeFatCrabTakerNotifTradeRspStruct_lift(_ buf: RustBuffer) throws -> FatCrabTakerNotifTradeRspStruct {
    return try FfiConverterTypeFatCrabTakerNotifTradeRspStruct.lift(buf)
}

public func FfiConverterTypeFatCrabTakerNotifTradeRspStruct_lower(_ value: FatCrabTakerNotifTradeRspStruct) -> RustBuffer {
    return FfiConverterTypeFatCrabTakerNotifTradeRspStruct.lower(value)
}

public struct RelayAddr {
    public var url: String
    public var socketAddr: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        url: String,
        socketAddr: String?
    ) {
        self.url = url
        self.socketAddr = socketAddr
    }
}

extension RelayAddr: Equatable, Hashable {
    public static func == (lhs: RelayAddr, rhs: RelayAddr) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.socketAddr != rhs.socketAddr {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(socketAddr)
    }
}

public struct FfiConverterTypeRelayAddr: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayAddr {
        return
            try RelayAddr(
                url: FfiConverterString.read(from: &buf),
                socketAddr: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: RelayAddr, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.socketAddr, into: &buf)
    }
}

public func FfiConverterTypeRelayAddr_lift(_ buf: RustBuffer) throws -> RelayAddr {
    return try FfiConverterTypeRelayAddr.lift(buf)
}

public func FfiConverterTypeRelayAddr_lower(_ value: RelayAddr) -> RustBuffer {
    return FfiConverterTypeRelayAddr.lower(value)
}

public struct RelayInfo {
    public var url: String
    public var status: RelayStatus
    public var document: RelayInformationDocument

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        url: String,
        status: RelayStatus,
        document: RelayInformationDocument
    ) {
        self.url = url
        self.status = status
        self.document = document
    }
}

extension RelayInfo: Equatable, Hashable {
    public static func == (lhs: RelayInfo, rhs: RelayInfo) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.document != rhs.document {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(status)
        hasher.combine(document)
    }
}

public struct FfiConverterTypeRelayInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayInfo {
        return
            try RelayInfo(
                url: FfiConverterString.read(from: &buf),
                status: FfiConverterTypeRelayStatus.read(from: &buf),
                document: FfiConverterTypeRelayInformationDocument.read(from: &buf)
            )
    }

    public static func write(_ value: RelayInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterTypeRelayStatus.write(value.status, into: &buf)
        FfiConverterTypeRelayInformationDocument.write(value.document, into: &buf)
    }
}

public func FfiConverterTypeRelayInfo_lift(_ buf: RustBuffer) throws -> RelayInfo {
    return try FfiConverterTypeRelayInfo.lift(buf)
}

public func FfiConverterTypeRelayInfo_lower(_ value: RelayInfo) -> RustBuffer {
    return FfiConverterTypeRelayInfo.lower(value)
}

public struct RelayInformationDocument {
    public var name: String?
    public var description: String?
    public var pubkey: String?
    public var contact: String?
    public var supportedNips: [UInt16]?
    public var software: String?
    public var version: String?
    public var relayCountries: [String]
    public var languageTags: [String]
    public var tags: [String]
    public var postingPolicy: String?
    public var paymentsUrl: String?
    public var icon: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        name: String?,
        description: String?,
        pubkey: String?,
        contact: String?,
        supportedNips: [UInt16]?,
        software: String?,
        version: String?,
        relayCountries: [String],
        languageTags: [String],
        tags: [String],
        postingPolicy: String?,
        paymentsUrl: String?,
        icon: String?
    ) {
        self.name = name
        self.description = description
        self.pubkey = pubkey
        self.contact = contact
        self.supportedNips = supportedNips
        self.software = software
        self.version = version
        self.relayCountries = relayCountries
        self.languageTags = languageTags
        self.tags = tags
        self.postingPolicy = postingPolicy
        self.paymentsUrl = paymentsUrl
        self.icon = icon
    }
}

extension RelayInformationDocument: Equatable, Hashable {
    public static func == (lhs: RelayInformationDocument, rhs: RelayInformationDocument) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.contact != rhs.contact {
            return false
        }
        if lhs.supportedNips != rhs.supportedNips {
            return false
        }
        if lhs.software != rhs.software {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.relayCountries != rhs.relayCountries {
            return false
        }
        if lhs.languageTags != rhs.languageTags {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        if lhs.postingPolicy != rhs.postingPolicy {
            return false
        }
        if lhs.paymentsUrl != rhs.paymentsUrl {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(pubkey)
        hasher.combine(contact)
        hasher.combine(supportedNips)
        hasher.combine(software)
        hasher.combine(version)
        hasher.combine(relayCountries)
        hasher.combine(languageTags)
        hasher.combine(tags)
        hasher.combine(postingPolicy)
        hasher.combine(paymentsUrl)
        hasher.combine(icon)
    }
}

public struct FfiConverterTypeRelayInformationDocument: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayInformationDocument {
        return
            try RelayInformationDocument(
                name: FfiConverterOptionString.read(from: &buf),
                description: FfiConverterOptionString.read(from: &buf),
                pubkey: FfiConverterOptionString.read(from: &buf),
                contact: FfiConverterOptionString.read(from: &buf),
                supportedNips: FfiConverterOptionSequenceUInt16.read(from: &buf),
                software: FfiConverterOptionString.read(from: &buf),
                version: FfiConverterOptionString.read(from: &buf),
                relayCountries: FfiConverterSequenceString.read(from: &buf),
                languageTags: FfiConverterSequenceString.read(from: &buf),
                tags: FfiConverterSequenceString.read(from: &buf),
                postingPolicy: FfiConverterOptionString.read(from: &buf),
                paymentsUrl: FfiConverterOptionString.read(from: &buf),
                icon: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: RelayInformationDocument, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.pubkey, into: &buf)
        FfiConverterOptionString.write(value.contact, into: &buf)
        FfiConverterOptionSequenceUInt16.write(value.supportedNips, into: &buf)
        FfiConverterOptionString.write(value.software, into: &buf)
        FfiConverterOptionString.write(value.version, into: &buf)
        FfiConverterSequenceString.write(value.relayCountries, into: &buf)
        FfiConverterSequenceString.write(value.languageTags, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
        FfiConverterOptionString.write(value.postingPolicy, into: &buf)
        FfiConverterOptionString.write(value.paymentsUrl, into: &buf)
        FfiConverterOptionString.write(value.icon, into: &buf)
    }
}

public func FfiConverterTypeRelayInformationDocument_lift(_ buf: RustBuffer) throws -> RelayInformationDocument {
    return try FfiConverterTypeRelayInformationDocument.lift(buf)
}

public func FfiConverterTypeRelayInformationDocument_lower(_ value: RelayInformationDocument) -> RustBuffer {
    return FfiConverterTypeRelayInformationDocument.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Auth {
    case none
    case userPass(
        username: String,
        password: String
    )
    case cookie(
        file: String
    )
}

public struct FfiConverterTypeAuth: FfiConverterRustBuffer {
    typealias SwiftType = Auth

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Auth {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .none

        case 2: return try .userPass(
                username: FfiConverterString.read(from: &buf),
                password: FfiConverterString.read(from: &buf)
            )

        case 3: return try .cookie(
                file: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Auth, into buf: inout [UInt8]) {
        switch value {
        case .none:
            writeInt(&buf, Int32(1))

        case let .userPass(username, password):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(username, into: &buf)
            FfiConverterString.write(password, into: &buf)

        case let .cookie(file):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(file, into: &buf)
        }
    }
}

public func FfiConverterTypeAuth_lift(_ buf: RustBuffer) throws -> Auth {
    return try FfiConverterTypeAuth.lift(buf)
}

public func FfiConverterTypeAuth_lower(_ value: Auth) -> RustBuffer {
    return FfiConverterTypeAuth.lower(value)
}

extension Auth: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BlockchainInfo {
    case electrum(
        url: String,
        network: Network
    )
    case rpc(
        url: String,
        auth: Auth,
        network: Network
    )
}

public struct FfiConverterTypeBlockchainInfo: FfiConverterRustBuffer {
    typealias SwiftType = BlockchainInfo

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockchainInfo {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .electrum(
                url: FfiConverterString.read(from: &buf),
                network: FfiConverterTypeNetwork.read(from: &buf)
            )

        case 2: return try .rpc(
                url: FfiConverterString.read(from: &buf),
                auth: FfiConverterTypeAuth.read(from: &buf),
                network: FfiConverterTypeNetwork.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BlockchainInfo, into buf: inout [UInt8]) {
        switch value {
        case let .electrum(url, network):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(url, into: &buf)
            FfiConverterTypeNetwork.write(network, into: &buf)

        case let .rpc(url, auth, network):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(url, into: &buf)
            FfiConverterTypeAuth.write(auth, into: &buf)
            FfiConverterTypeNetwork.write(network, into: &buf)
        }
    }
}

public func FfiConverterTypeBlockchainInfo_lift(_ buf: RustBuffer) throws -> BlockchainInfo {
    return try FfiConverterTypeBlockchainInfo.lift(buf)
}

public func FfiConverterTypeBlockchainInfo_lower(_ value: BlockchainInfo) -> RustBuffer {
    return FfiConverterTypeBlockchainInfo.lower(value)
}

extension BlockchainInfo: Equatable, Hashable {}

public enum FatCrabError {
    case TxNotFound
    case TxUnconfirmed
    case Simple(
        description: String
    )
    case N3xb(
        description: String
    )
    case BdkBip39(
        description: String
    )
    case Bdk(
        description: String
    )
    case Io(
        description: String
    )
    case JoinError(
        description: String
    )
    case SerdesJson(
        description: String
    )
    case UrlParse(
        description: String
    )
    case MpscSend(
        description: String
    )
    case OneshotRecv(
        description: String
    )

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeFatCrabError.lift(error)
    }
}

public struct FfiConverterTypeFatCrabError: FfiConverterRustBuffer {
    typealias SwiftType = FatCrabError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .TxNotFound
        case 2: return .TxUnconfirmed
        case 3: return try .Simple(
                description: FfiConverterString.read(from: &buf)
            )
        case 4: return try .N3xb(
                description: FfiConverterString.read(from: &buf)
            )
        case 5: return try .BdkBip39(
                description: FfiConverterString.read(from: &buf)
            )
        case 6: return try .Bdk(
                description: FfiConverterString.read(from: &buf)
            )
        case 7: return try .Io(
                description: FfiConverterString.read(from: &buf)
            )
        case 8: return try .JoinError(
                description: FfiConverterString.read(from: &buf)
            )
        case 9: return try .SerdesJson(
                description: FfiConverterString.read(from: &buf)
            )
        case 10: return try .UrlParse(
                description: FfiConverterString.read(from: &buf)
            )
        case 11: return try .MpscSend(
                description: FfiConverterString.read(from: &buf)
            )
        case 12: return try .OneshotRecv(
                description: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FatCrabError, into buf: inout [UInt8]) {
        switch value {
        case .TxNotFound:
            writeInt(&buf, Int32(1))

        case .TxUnconfirmed:
            writeInt(&buf, Int32(2))

        case let .Simple(description):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(description, into: &buf)

        case let .N3xb(description):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(description, into: &buf)

        case let .BdkBip39(description):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(description, into: &buf)

        case let .Bdk(description):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(description, into: &buf)

        case let .Io(description):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(description, into: &buf)

        case let .JoinError(description):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(description, into: &buf)

        case let .SerdesJson(description):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(description, into: &buf)

        case let .UrlParse(description):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(description, into: &buf)

        case let .MpscSend(description):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(description, into: &buf)

        case let .OneshotRecv(description):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(description, into: &buf)
        }
    }
}

extension FatCrabError: Equatable, Hashable {}

extension FatCrabError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FatCrabMakerState {
    case new
    case waitingForOffers
    case receivedOffer
    case acceptedOffer
    case inboundBtcNotified
    case inboundFcNotified
    case notifiedOutbound
    case tradeCompleted
}

public struct FfiConverterTypeFatCrabMakerState: FfiConverterRustBuffer {
    typealias SwiftType = FatCrabMakerState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabMakerState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .new

        case 2: return .waitingForOffers

        case 3: return .receivedOffer

        case 4: return .acceptedOffer

        case 5: return .inboundBtcNotified

        case 6: return .inboundFcNotified

        case 7: return .notifiedOutbound

        case 8: return .tradeCompleted

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FatCrabMakerState, into buf: inout [UInt8]) {
        switch value {
        case .new:
            writeInt(&buf, Int32(1))

        case .waitingForOffers:
            writeInt(&buf, Int32(2))

        case .receivedOffer:
            writeInt(&buf, Int32(3))

        case .acceptedOffer:
            writeInt(&buf, Int32(4))

        case .inboundBtcNotified:
            writeInt(&buf, Int32(5))

        case .inboundFcNotified:
            writeInt(&buf, Int32(6))

        case .notifiedOutbound:
            writeInt(&buf, Int32(7))

        case .tradeCompleted:
            writeInt(&buf, Int32(8))
        }
    }
}

public func FfiConverterTypeFatCrabMakerState_lift(_ buf: RustBuffer) throws -> FatCrabMakerState {
    return try FfiConverterTypeFatCrabMakerState.lift(buf)
}

public func FfiConverterTypeFatCrabMakerState_lower(_ value: FatCrabMakerState) -> RustBuffer {
    return FfiConverterTypeFatCrabMakerState.lower(value)
}

extension FatCrabMakerState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FatCrabOrderType {
    case buy
    case sell
}

public struct FfiConverterTypeFatCrabOrderType: FfiConverterRustBuffer {
    typealias SwiftType = FatCrabOrderType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabOrderType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .buy

        case 2: return .sell

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FatCrabOrderType, into buf: inout [UInt8]) {
        switch value {
        case .buy:
            writeInt(&buf, Int32(1))

        case .sell:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFatCrabOrderType_lift(_ buf: RustBuffer) throws -> FatCrabOrderType {
    return try FfiConverterTypeFatCrabOrderType.lift(buf)
}

public func FfiConverterTypeFatCrabOrderType_lower(_ value: FatCrabOrderType) -> RustBuffer {
    return FfiConverterTypeFatCrabOrderType.lower(value)
}

extension FatCrabOrderType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FatCrabTakerState {
    case new
    case submittedOffer
    case offerAccepted
    case offerRejected
    case notifiedOutbound
    case inboundBtcNotified
    case inboundFcNotified
    case tradeCompleted
}

public struct FfiConverterTypeFatCrabTakerState: FfiConverterRustBuffer {
    typealias SwiftType = FatCrabTakerState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabTakerState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .new

        case 2: return .submittedOffer

        case 3: return .offerAccepted

        case 4: return .offerRejected

        case 5: return .notifiedOutbound

        case 6: return .inboundBtcNotified

        case 7: return .inboundFcNotified

        case 8: return .tradeCompleted

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FatCrabTakerState, into buf: inout [UInt8]) {
        switch value {
        case .new:
            writeInt(&buf, Int32(1))

        case .submittedOffer:
            writeInt(&buf, Int32(2))

        case .offerAccepted:
            writeInt(&buf, Int32(3))

        case .offerRejected:
            writeInt(&buf, Int32(4))

        case .notifiedOutbound:
            writeInt(&buf, Int32(5))

        case .inboundBtcNotified:
            writeInt(&buf, Int32(6))

        case .inboundFcNotified:
            writeInt(&buf, Int32(7))

        case .tradeCompleted:
            writeInt(&buf, Int32(8))
        }
    }
}

public func FfiConverterTypeFatCrabTakerState_lift(_ buf: RustBuffer) throws -> FatCrabTakerState {
    return try FfiConverterTypeFatCrabTakerState.lift(buf)
}

public func FfiConverterTypeFatCrabTakerState_lower(_ value: FatCrabTakerState) -> RustBuffer {
    return FfiConverterTypeFatCrabTakerState.lower(value)
}

extension FatCrabTakerState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FatCrabTradeRsp {
    case accept(
        receiveAddress: String
    )
    case reject
}

public struct FfiConverterTypeFatCrabTradeRsp: FfiConverterRustBuffer {
    typealias SwiftType = FatCrabTradeRsp

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabTradeRsp {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .accept(
                receiveAddress: FfiConverterString.read(from: &buf)
            )

        case 2: return .reject

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FatCrabTradeRsp, into buf: inout [UInt8]) {
        switch value {
        case let .accept(receiveAddress):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(receiveAddress, into: &buf)

        case .reject:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFatCrabTradeRsp_lift(_ buf: RustBuffer) throws -> FatCrabTradeRsp {
    return try FfiConverterTypeFatCrabTradeRsp.lift(buf)
}

public func FfiConverterTypeFatCrabTradeRsp_lower(_ value: FatCrabTradeRsp) -> RustBuffer {
    return FfiConverterTypeFatCrabTradeRsp.lower(value)
}

extension FatCrabTradeRsp: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FatCrabTradeRspType {
    case accept
    case reject
}

public struct FfiConverterTypeFatCrabTradeRspType: FfiConverterRustBuffer {
    typealias SwiftType = FatCrabTradeRspType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FatCrabTradeRspType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .accept

        case 2: return .reject

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FatCrabTradeRspType, into buf: inout [UInt8]) {
        switch value {
        case .accept:
            writeInt(&buf, Int32(1))

        case .reject:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFatCrabTradeRspType_lift(_ buf: RustBuffer) throws -> FatCrabTradeRspType {
    return try FfiConverterTypeFatCrabTradeRspType.lift(buf)
}

public func FfiConverterTypeFatCrabTradeRspType_lower(_ value: FatCrabTradeRspType) -> RustBuffer {
    return FfiConverterTypeFatCrabTradeRspType.lower(value)
}

extension FatCrabTradeRspType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FilterLevel {
    case trace
    case debug
    case info
    case warn
    case error
}

public struct FfiConverterTypeFilterLevel: FfiConverterRustBuffer {
    typealias SwiftType = FilterLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FilterLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .trace

        case 2: return .debug

        case 3: return .info

        case 4: return .warn

        case 5: return .error

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FilterLevel, into buf: inout [UInt8]) {
        switch value {
        case .trace:
            writeInt(&buf, Int32(1))

        case .debug:
            writeInt(&buf, Int32(2))

        case .info:
            writeInt(&buf, Int32(3))

        case .warn:
            writeInt(&buf, Int32(4))

        case .error:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeFilterLevel_lift(_ buf: RustBuffer) throws -> FilterLevel {
    return try FfiConverterTypeFilterLevel.lift(buf)
}

public func FfiConverterTypeFilterLevel_lower(_ value: FilterLevel) -> RustBuffer {
    return FfiConverterTypeFilterLevel.lower(value)
}

extension FilterLevel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    case bitcoin
    case testnet
    case signet
    case regtest
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .bitcoin

        case 2: return .testnet

        case 3: return .signet

        case 4: return .regtest

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        case .bitcoin:
            writeInt(&buf, Int32(1))

        case .testnet:
            writeInt(&buf, Int32(2))

        case .signet:
            writeInt(&buf, Int32(3))

        case .regtest:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}

extension Network: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RelayStatus {
    case initialized
    case pending
    case connecting
    case connected
    case disconnected
    case stopped
    case terminated
}

public struct FfiConverterTypeRelayStatus: FfiConverterRustBuffer {
    typealias SwiftType = RelayStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .initialized

        case 2: return .pending

        case 3: return .connecting

        case 4: return .connected

        case 5: return .disconnected

        case 6: return .stopped

        case 7: return .terminated

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayStatus, into buf: inout [UInt8]) {
        switch value {
        case .initialized:
            writeInt(&buf, Int32(1))

        case .pending:
            writeInt(&buf, Int32(2))

        case .connecting:
            writeInt(&buf, Int32(3))

        case .connected:
            writeInt(&buf, Int32(4))

        case .disconnected:
            writeInt(&buf, Int32(5))

        case .stopped:
            writeInt(&buf, Int32(6))

        case .terminated:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeRelayStatus_lift(_ buf: RustBuffer) throws -> RelayStatus {
    return try FfiConverterTypeRelayStatus.lift(buf)
}

public func FfiConverterTypeRelayStatus_lower(_ value: RelayStatus) -> RustBuffer {
    return FfiConverterTypeRelayStatus.lower(value)
}

extension RelayStatus: Equatable, Hashable {}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFatCrabPeerEnvelope: FfiConverterRustBuffer {
    typealias SwiftType = FatCrabPeerEnvelope?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFatCrabPeerEnvelope.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFatCrabPeerEnvelope.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFatCrabTradeRspEnvelope: FfiConverterRustBuffer {
    typealias SwiftType = FatCrabTradeRspEnvelope?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFatCrabTradeRspEnvelope.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFatCrabTradeRspEnvelope.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFatCrabOrderType: FfiConverterRustBuffer {
    typealias SwiftType = FatCrabOrderType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFatCrabOrderType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFatCrabOrderType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]

    public static func write(_ value: [UInt16], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt16.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt16]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt16.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFatCrabOfferEnvelope: FfiConverterRustBuffer {
    typealias SwiftType = [FatCrabOfferEnvelope]

    public static func write(_ value: [FatCrabOfferEnvelope], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFatCrabOfferEnvelope.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FatCrabOfferEnvelope] {
        let len: Int32 = try readInt(&buf)
        var seq = [FatCrabOfferEnvelope]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFatCrabOfferEnvelope.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFatCrabOrderEnvelope: FfiConverterRustBuffer {
    typealias SwiftType = [FatCrabOrderEnvelope]

    public static func write(_ value: [FatCrabOrderEnvelope], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFatCrabOrderEnvelope.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FatCrabOrderEnvelope] {
        let len: Int32 = try readInt(&buf)
        var seq = [FatCrabOrderEnvelope]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFatCrabOrderEnvelope.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeRelayAddr: FfiConverterRustBuffer {
    typealias SwiftType = [RelayAddr]

    public static func write(_ value: [RelayAddr], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRelayAddr.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RelayAddr] {
        let len: Int32 = try readInt(&buf)
        var seq = [RelayAddr]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeRelayAddr.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeRelayInfo: FfiConverterRustBuffer {
    typealias SwiftType = [RelayInfo]

    public static func write(_ value: [RelayInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRelayInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RelayInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [RelayInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeRelayInfo.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringTypeFatCrabBuyMaker: FfiConverterRustBuffer {
    public static func write(_ value: [String: FatCrabBuyMaker], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeFatCrabBuyMaker.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: FatCrabBuyMaker] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: FatCrabBuyMaker]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeFatCrabBuyMaker.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringTypeFatCrabBuyTaker: FfiConverterRustBuffer {
    public static func write(_ value: [String: FatCrabBuyTaker], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeFatCrabBuyTaker.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: FatCrabBuyTaker] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: FatCrabBuyTaker]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeFatCrabBuyTaker.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringTypeFatCrabSellMaker: FfiConverterRustBuffer {
    public static func write(_ value: [String: FatCrabSellMaker], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeFatCrabSellMaker.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: FatCrabSellMaker] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: FatCrabSellMaker]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeFatCrabSellMaker.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryStringTypeFatCrabSellTaker: FfiConverterRustBuffer {
    public static func write(_ value: [String: FatCrabSellTaker], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeFatCrabSellTaker.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: FatCrabSellTaker] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: FatCrabSellTaker]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeFatCrabSellTaker.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func initTracingForOslog(level: FilterLevel, logTimestamp: Bool, logLevel: Bool) {
    try! rustCall {
        uniffi_fatcrab_trading_fn_func_init_tracing_for_oslog(
            FfiConverterTypeFilterLevel.lower(level),
            FfiConverterBool.lower(logTimestamp),
            FfiConverterBool.lower(logLevel), $0
        )
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_fatcrab_trading_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_fatcrab_trading_checksum_func_init_tracing_for_oslog() != 16348 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_get_order_details() != 19480 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_get_peer_pubkey() != 41726 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_get_state() != 43680 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_post_new_order() != 50978 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_query_offers() != 40742 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_query_peer_msg() != 64488 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_register_notif_delegate() != 60088 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_release_notify_peer() != 58401 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_trade_complete() != 21532 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_trade_response() != 32468 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuymaker_unregister_notif_delegate() != 7463 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuytaker_check_btc_tx_confirmation() != 21782 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuytaker_get_order_details() != 47237 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuytaker_get_peer_btc_txid() != 46072 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuytaker_get_state() != 46577 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuytaker_notify_peer() != 22205 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuytaker_query_trade_rsp() != 9656 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuytaker_register_notif_delegate() != 47664 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuytaker_take_order() != 59689 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuytaker_trade_complete() != 19394 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabbuytaker_unregister_notif_delegate() != 43340 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabmakernotifdelegate_on_maker_offer_notif() != 33127 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabmakernotifdelegate_on_maker_peer_notif() != 38177 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabofferenvelope_pubkey() != 42915 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcraborderenvelope_order() != 3245 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcraborderenvelope_pubkey() != 57252 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabpeerenvelope_message() != 13486 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_check_btc_tx_confirmation() != 20595 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_get_order_details() != 25127 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_get_peer_btc_txid() != 60443 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_get_peer_pubkey() != 1205 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_get_state() != 58280 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_notify_peer() != 49599 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_post_new_order() != 51815 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_query_offers() != 36564 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_query_peer_msg() != 26448 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_register_notif_delegate() != 51605 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_trade_complete() != 50569 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_trade_response() != 56194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabsellmaker_unregister_notif_delegate() != 39888 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabselltaker_get_order_details() != 49172 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabselltaker_get_state() != 22729 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabselltaker_register_notif_delegate() != 24573 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabselltaker_take_order() != 14858 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabselltaker_trade_complete() != 1972 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabselltaker_unregister_notif_delegate() != 21142 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtakernotifdelegate_on_taker_peer_notif() != 5296 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtakernotifdelegate_on_taker_trade_rsp_notif() != 41346 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtraderspenvelope_trade_rsp() != 618 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_add_relays() != 61191 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_get_buy_makers() != 26457 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_get_buy_takers() != 47337 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_get_relays() != 18279 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_get_sell_makers() != 2964 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_get_sell_takers() != 47030 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_new_buy_maker() != 36995 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_new_buy_taker() != 18291 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_new_sell_maker() != 3595 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_new_sell_taker() != 11994 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_nostr_pubkey() != 2194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_query_orders() != 22304 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_reconnect() != 59876 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_remove_relay() != 4663 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_shutdown() != 41940 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_wallet_balances() != 12565 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_wallet_bip39_mnemonic() != 57026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_wallet_blockchain_sync() != 42503 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_wallet_generate_receive_address() != 62222 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_method_fatcrabtrader_wallet_send_to_address() != 63105 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_constructor_fatcrabtrader_new() != 46569 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_fatcrab_trading_checksum_constructor_fatcrabtrader_new_with_mnemonic() != 53834 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitFatCrabMakerNotifDelegate()
    uniffiCallbackInitFatCrabTakerNotifDelegate()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
